import {
    createAsyncThunk,
    createSelector,
    createSlice,
    PayloadAction,
} from '@reduxjs/toolkit';
import { RootState } from '../../app/store';
import { _getQuestions } from '../../utils/_DATA';
import Question from '../../utils/question';

export interface QuestionsState {
    questions: Question[];
    status: 'idle' | 'loading' | 'failed';
    filter: 'all' | 'answered' | 'new';
}

const initialState: QuestionsState = {
    questions: [],
    status: 'idle',
    filter: 'new',
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchQuestions = createAsyncThunk(
    'questions/fetchQuestions',
    async () => {
        const response = await _getQuestions();
        const questions: Question[] = Object.values(response.questions).map((question) => question);
        return questions;
    }
);

export const fetchQuestionByID = createAsyncThunk(
    'questions/fetchByIDStatus',
    async (questionID: string) => {

        const response = await _getQuestions();

        const questions: Question[] = Object.values(response.questions).map((question) => question);

        const question = questions.find((question) => question.id === questionID);

        if (question === undefined) { throw new Error('Question not found') }

        return question;
    }
);

export const questionsSlice = createSlice({
    name: 'questions',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setFilter: (state, action: PayloadAction<QuestionsState['filter']>) => {
            state.filter = action.payload;
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    extraReducers: (builder) => {
        builder
            .addCase(fetchQuestions.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(fetchQuestions.fulfilled, (state, action: PayloadAction<Question[]>) => {
                state.status = 'idle';
                state.questions = action.payload;
            })
            .addCase(fetchQuestions.rejected, (state) => {
                state.status = 'failed';
            })
            .addCase(fetchQuestionByID.pending, (state) => {
                state.status = 'loading';
            })
            .addCase(fetchQuestionByID.fulfilled, (state, action: PayloadAction<Question>) => {
                state.status = 'idle';
                const index = state.questions.findIndex(q => q.id === action.payload.id);
                if (index !== -1) {
                    state.questions[index] = action.payload;
                } else {
                    state.questions.push(action.payload);
                }
            })
            .addCase(fetchQuestionByID.rejected, (state) => {
                state.status = 'failed';
            });
    },
});

export const status = (state: RootState) => state.questionsState.status;
export const allQuestions = (state: RootState) => state.questionsState.questions;
export const questionsFilter = (state: RootState) => state.questionsState.filter;
export const setFilter = questionsSlice.actions.setFilter;

export const newQuestions = createSelector(
    (state: RootState) => state.questionsState.questions,
    (state: RootState) => state.authedUser.user,
    (questions, user) => {
        const filteredQuestions = user ?
            questions?.filter((question) => !didAuthedUserVoted(question, user?.id))
            : questions?.filter((question) => !didQuestionWasAnswered(question))

        return filteredQuestions.sort((a: Question, b: Question) => b.timestamp - a.timestamp)
    },
);

export const answeredQuestions = createSelector(
    (state: RootState) => state.questionsState.questions,
    (state: RootState) => state.authedUser.user,
    (questions, user) => {
        const filteredQuestions = user ?
            questions?.filter((question) => didAuthedUserVoted(question, user?.id))
            : questions?.filter((question) => didQuestionWasAnswered(question))

        return filteredQuestions.sort((a: Question, b: Question) => b.timestamp - a.timestamp)
    }
);

export const getQuestionByID = (state: RootState, questionID: string) => state.questionsState.questions
    .find((question) => question.id === questionID);

export default questionsSlice.reducer;


// #region Utils
function didAuthedUserVoted(question: Question, userId: string): boolean {
    const mergedVotes = [...question.optionOne.votes, ...question.optionTwo.votes]
    return mergedVotes.includes(userId)
}

function didQuestionWasAnswered(question: Question): boolean {
    const mergedVotes = [...question.optionOne.votes, ...question.optionTwo.votes]
    return mergedVotes.length > 0
}
// #endregion Utils